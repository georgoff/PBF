---
title: "Seasonal Reproductive Numbers"
author: "David L Smith"
date: "2/15/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(RColorBrewer)
colN <- 20

qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
pie(rep(1,colN), col=sample(col_vector, colN))
```

## Seasonal Reproductive Numbers

How do we compute $R_C$ in places where transmission is seasonal? The problem for computing an "average" is that the expected number of cases per case is different depending on when in the year a case was acquired. At the end of the transmission season, most of the infectious days will occur in the trough. The answer to this question involves computing the lead eigenvalue and its associated eigenvector for the next generation operator. Here, we illustrate the concepts by constructing examples. 

### Seasonality in Vectorial Capacity

We have to be clear on what we mean by "seasonality." One way to do this is to specify a daily varying vectorial capacity -- how many infectious bites would eventually arise from all the mosquitoes feeding on this one human each day of the year? For purposes of this exercise, we will construct these objects. 

The first step in our algorithm is thus to specify the seasonal pattern of the relative value of vectorial capacity. We will constrain this mathematical object so that we can set the mean intensity of transmission to any value we want. We thus modify it to have an arithmetic mean of one, when averaged over a year. For convenience, the following function constructs several different patterns, with a switch: 

```{r, echo=FALSE}

makeVCrel = function(pattern="sin", Nyr = 5, showit=FALSE){
  VC = switch(pattern, 
         sin = pmax(0.5 + cos (2*pi*c(1:365)/365),0), 
         sin1 = 1.1 + cos (2*pi*c(1:365)/365), 
         block = c(rep(2,183), rep(.1,182)))
  VC = VC/mean(VC)
  VCrel = rep(VC, Nyr)
  
  if(showit == TRUE) 
    plot(1:(365*Nyr)/365, VCrel, type = "l", xlab = "Year", 
        ylim = c(0, max(VCrel)), ylab = "Seasonal Pattern")
  VCrel
}
```

This is one particular pattern, based on a sinusoidal transmission pattern

```{r, fig=TRUE}
VCrel = makeVCrel(pattern="sin", Nyr = 10, showit=TRUE)
```

Here's another, more block-like

```{r, fig=TRUE}
VCrel = makeVCrel(pattern="block", showit=TRUE)
```

### The Temporal Dispersion of VC

To compute the next generation for the temporal operator, we have to be very specific about when the infectious bites occur.  VC only describes bites arising, but under the standard model, it is possible to write out a formula describing when they would be expected to occur. 

```{r, fig=TRUE, echo=FALSE}

makeVCtime = function(EIP=12, p=.9, a=.3, tol = 0.001, plot=FALSE){
  VCn =  log(tol)/log(p)
  VCtime = c(rep(0, EIP-1), p^c(1:VCn)*a) 
  VCtime = VCtime/sum(VCtime)
  if(plot == TRUE) plotVCtime(VCtime, EIP)
  VCtime
}

plotVCtime = function(VCtime, EIP){
  ix = 1:length(VCtime)
  plot(ix, VCtime/max(VCtime), type ="n", 
       xlab = "Day", ylab = expression(VC(t)), main = "Temporal Dispersion of VC")
  vix = ix[-c(1:(EIP-1))]
  lines(vix, VCtime[vix]/max(VCtime))
  segments(EIP,.2,EIP,1, lty = 2)
  text(EIP, .1, "EIP")
}

```

The temporal dispersion of VC looks like this (the maximum is scaled arbitrarily to one):

```{r}
VCtime = makeVCtime(plot=TRUE)
```

### HTC and its temporal dispersion

We also need the temporal dispersion of infectiousness of humans. Here it is scaled arbitrarily to one: 

```{r, echo=FALSE, fig=TRUE}
makeDtime = function(D=38, plot=FALSE){ 
  Dtime = c(rep(0, 17), dgamma(1:365, 2, .05))
  if(plot==TRUE)
    plot(1:365, Dtime[1:365]/max(Dtime), type = "l", ylab = expression(D(t)), xlab = "Time (Days)")
  D*Dtime/sum(Dtime)
}
Dtime = makeDtime(plot=TRUE) 
```

### The Temporal Disribution of Rc 

For a human case that started on some day, when would the next cases arise?  This is the question we must take up with the temporal next-generation operator. 
Given the dispersion in mosquitoes and humans, the temporal dispersion of $R_0$ looks like this: 
```{r}
makeRtime = function(Re = 1, VCtime=makeVCtime(), Dtime=makeDtime(), plot=FALSE){
  Rt = 1:(365+length(Dtime))
  Rtime = Rt*0
  ix = 1:length(VCtime)
  ixx = 1:length(Dtime)
  #for(t in ix) Rtime[t+ixx] = Rtime[t+ixx] + VCtime[t]*Dtime
  for(t in ixx) Rtime[t+ix] = Rtime[t+ix] + VCtime*Dtime[t]
  
  Rtime = Rtime[1:365]
  Rtime = Re*Rtime/sum(Rtime)
  if (plot == TRUE){
    plot(c(1:365), Re*Rtime/max(Rtime), type = "l", ylab = expression(R[0](t)), xlab = "Time (Days)", col = "blue")
    lines(1:365, Re*cumsum(Rtime/sum(Rtime)))
  }
  Rtime
}

Rtime = makeRtime(2, plot=TRUE)

```
```{r}
plot(1:365, Rtime/max(Rtime), type = "l", col = "purple")
lines(1:length(VCtime), VCtime/max(VCtime), col="darkblue")
lines(1:365, Dtime[1:365]/max(Dtime), col="darkred")
```

```{r}
VCrel = makeVCrel("sin", Nyr=10)

nextGen = function(gen, Rtime, VCrel, clr = "black", yoffset=0, mag=1, norm = FALSE, flr= .005){
  L = length(Rtime)
  xix = 1:L
  genN = c(1:3650)*0
  for(t in 1:3650){
    tt = t%%365+1
    genN[t+xix] = genN[t+xix] + Rtime*gen[t]*VCrel[tt]
  }
  genN = genN[1:3650]
  ix = which(genN > flr)
  if(norm == TRUE)
     lines(c(1:3650)[ix], mag*genN[ix]/max(genN)+yoffset, col = clr)
  if(norm == FALSE)
    lines(c(1:3650)[ix], mag*genN[ix]+yoffset, col = clr)
  genN
} 




Re=3
Rtime = Re*Rtime/sum(Rtime)
RRe = sum(Rtime)
plot(1:3650, 8*VCrel/max(VCrel), type = "l", lwd=1, col = grey(0.5), ylim = c(0,9), ylab = "", yaxt = "n", xaxt = "n", xlab = "Time (Years)", main = "40 Generations")
axis(1, c(0:10)*365, c(0:10))
segments(1,0,1,1)
genN = c(0,1, rep(0,3648))
NN = 40 

for(i in 1:NN){
  genN = nextGen(genN, Rtime, VCrel, yoffset=i/6, mag=3.5, clr=col_vector[i%%colN +1], norm=TRUE, flr=0.008)
  RRe = c(RRe, sum(genN))
} 
eigenval = RRe[-1]/RRe[-length(RRe)]
```

```{r}
plot(eigenval[1:30], type = "l")
```

```{r, echo=FALSE, fig=TRUE, fig.height=12, fig.width=4}

nextGen1 = function(gen, Rtime, VCrel, clr = "black", xoffset=0, yoffset=0, mag=.95, lines=FALSE, nextline=FALSE){
  xix = 1:365
  genN = c(1:2000)*0
  for(t in 1:1635){
    tt = t%%365+1
    genN[t+xix] = genN[t+xix] + Rtime*gen[tt]*VCrel[tt]
  }
  genN = genN[366:730]
  if(lines == TRUE)
    lines(1:365 + xoffset, mag*genN/max(genN) + yoffset, col = clr, lwd=2)
  if(nextline == TRUE)
    lines(1:365 + xoffset, mag*genN/max(genN) + yoffset-1, col = grey(0.85), lwd=2)
  genN
}

plotEigen = function(NGEN, Rtime, VCrel){
  
  plot(1:365,NGEN+2+.95*(VCrel[1:365]/max(VCrel[1:365])), lwd=2, type = "l", ylim = c(0,NGEN+2.5), col = "darkblue", xaxt = "n", xlab = "Month of Year", ylab = "Seasonal Pattern by Generation", yaxt = "n", main = "Generations               ")
  segments(0,NGEN+2,0,NGEN+2.95, lwd=2)
  segments(0,NGEN+1,0,NGEN+1.95, lwd=2, col = grey(0.55))
  axis(1, c(0:12)*365/12, c(0:12)) 
  axis(2, c(0:(NGEN+2))+.5, c(paste(">", NGEN*2), paste(">", NGEN), c((NGEN):0)))


  genN = c(1, rep(0, 364))
  RRe = sum(genN)
  for(i in 1:NGEN){
    genN = nextGen1(genN, Rtime, VCrel, yoffset = NGEN+2-i, nextline=TRUE, lines=TRUE,col_vector[i])
    RRe = c(RRe, sum(genN))
  } 
  for(i in 1:NGEN){
    genN = nextGen1(genN, Rtime, VCrel, clr = grey(0.5), yoffset = 1, lines=TRUE)
    RRe = c(RRe, sum(genN))
  } 

  for(i in -1:(NGEN+2))
    segments(0, i-0.02, 365, i-0.02, col = grey(0.8))

  genN = nextGen1(genN, Rtime, VCrel, clr = grey(0.5), lines=TRUE)
  c(RRe, sum(genN))
  eigs = RRe[-1]/RRe[-length(RRe)]
}
eigs = plotEigen(15, Rtime, VCrel)
```
```{r}
plot(eigs, type = "l")
```

```{r}
nextGenSeas = function(gen, Rtime, VCrel,norm=FALSE){
  L = length(Rtime)
  xix = 1:L
  tt = 1:length(gen)
  genN = tt*0
  for(t in tt){
    ty = t%%365+1
    genN[t+xix] = genN[t+xix] + Rtime*gen[t]*VCrel[ty]
  }
 genN=genN[tt]
 if(norm==TRUE) genN = genN/sum(genN, na.rm=TRUE)
 genN
}

nextGenSeasMat = function(gen, Rtime, VCrel, Nyr, NN=40, norm=FALSE, showit=TRUE){
  for(i in 1:NN){
    genN = nextGenSeas(genN, Rtime, VCrel, norm)
    gen = rbind(gen, genN)
  }
  if(showit==TRUE) generationsPlot(gen, Nyr)
  gen
}

generationsPlot = function(gen, Nyr){
  tot = colSums(gen[-1,], na.rm=T)
  tt = 1:dim(gen)[2]
plot(tt, tot, type = "l", xaxt = "n", xlab = "Time (Years)", ylab = "Generations", ylim = c(0,1.15*max(tot, na.rm=T))) 
axis(1, 365*c(0:Nyr), c(0:Nyr))
NN = dim(gen)[1]
for(i in NN:1){
  if(i==1) toti = gen[1,]
  if(i>1) toti = colSums(gen[1:i,], na.rm=T)
  xx = c(tt, max(tt), 1)
  yy = c(toti, 0, 0) 
  clr = col_vector[i%%colN +1]
  polygon(xx, yy, col= clr, border=clr)
  xpos = max(tt)*(i+2)/(NN+4)
  ypos = 1.05*max(tot)
  points(xpos, ypos, pch = 15, col = clr) 
  if(i%%5 == 1) text(xpos, ypos, i-1, pos=3)
}
lines(tt, .8*max(tot)*VCrel/max(VCrel), col = grey(0.55))
}



```

```{r}
VCrel = makeVCrel(pattern="sin", Nyr=10)
Rtime = 2.6*Rtime/sum(Rtime)
genN = c(0,1, rep(0,3648))
gen = nextGenSeasMat(genN, Rtime, VCrel, Nyr = 10, 48, showit=TRUE)

#generationsPlot(gen)
```

